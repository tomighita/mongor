use mongodb::bson::{Document, doc};
use serde_json;
use serial_test::serial;

// Import test environment and utilities from utils module
mod utils;
use utils::test_environment::TestEnvironment;
use utils::utils::{make_http_request, make_post_request};

// Base name for test collections
static TEST_COLLECTION_BASE_NAME: &str = "mongor_post_endpoint_test";

// Generate a unique collection name for each test
fn unique_collection_name(test_name: &str) -> String {
    format!(
        "{}_{}",
        TEST_COLLECTION_BASE_NAME,
        test_name.replace(" ", "_")
    )
}

/// Run a POST endpoint test with the given parameters
///
/// This function:
/// 1. Creates a test environment (MongoDB + app)
/// 2. Creates a collection with a unique name
/// 3. Makes a POST request to the endpoint with the provided document
/// 4. Verifies the response status code is 201 (Created)
/// 5. Makes a GET request to verify the document was inserted
/// 6. Automatically cleans up all processes when the test environment is dropped
fn run_post_endpoint_test(test_name: &str, document_to_insert: Document) {
    // Create test environment (starts MongoDB and app)
    let env = TestEnvironment::new();

    // Generate a unique collection name for this test
    let collection_name = unique_collection_name(test_name);

    // Ensure the collection exists but is empty
    env.insert_test_data(&collection_name, Vec::new());

    // Convert document to JSON string for the request
    let json_body =
        serde_json::to_string(&document_to_insert).expect("Failed to convert document to JSON");

    // Make a POST request to our endpoint
    let full_request_path = format!("/{}", collection_name);
    let (status_code, _body) = make_post_request(&full_request_path, &json_body);

    // Verify the response status code is 201 (Created)
    assert_eq!(
        status_code, 201,
        "Expected status code 201, got {}",
        status_code
    );

    // Now make a GET request to verify the document was inserted
    let (get_status_code, get_body) = make_http_request(&full_request_path);

    // Verify the GET response
    assert_eq!(
        get_status_code, 200,
        "Expected GET status code 200, got {}",
        get_status_code
    );

    // Parse the JSON response into BSON documents
    let documents: Vec<Document> =
        serde_json::from_str(&get_body).expect("Failed to parse JSON response");

    // Verify the document was inserted (ignoring the _id field which is generated by MongoDB)
    assert_eq!(
        documents.len(),
        1,
        "Expected 1 document, got {}",
        documents.len()
    );

    // The test environment will be automatically cleaned up when it goes out of scope
}

#[test]
#[serial]
fn test_post_simple_document() {
    // Test document to insert
    let test_doc = doc! {
        "name": "test document",
        "value": 42
    };

    // Run the test
    run_post_endpoint_test("simple document", test_doc);
}

#[test]
#[serial]
fn test_post_complex_document() {
    // Test document with nested fields
    let test_doc = doc! {
        "name": "complex document",
        "nested": {
            "field1": "value1",
            "field2": 123
        },
        "array": ["item1", "item2", "item3"]
    };

    // Run the test
    run_post_endpoint_test("complex document", test_doc);
}
